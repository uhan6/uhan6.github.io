---
title: 'Java测试驱动开发'
category: 后端 
tags: [Java, 测试]
---
## 1. 为什么要测试驱动开发 
使用测试驱动开发(Test-driven development, TDD)能缩短产品上线时间、简化重构工作、帮助创建更好的设计以及降低耦合程度。除此之外，TDD还是其他实践(如持续交付)的前提条件。

## 2. 理解测试驱动开发

测试驱动开发是一个过程，依赖于不断重复极短的开发周期。我们一般将这个周期称为“红灯-绿灯-重构”。

实现这个流程其实很简单

```Text
1. 编写一个测试
2. 运行所有测试 // 红灯，因为还没有实现
3. 编写实现代码
4. 运行所有测试 // 绿灯，编写实现直至测试通过
5. 重构
6. 运行所有测试 // 绿灯，保证重构不会破坏已有功能
```

## 3. 测试工具

1.单元测试框架  
常用的单元测试框架有JUnit和TestNG。JUnit是IDEA编译器自带的测试框架，使用简单便捷。JUnit的每个测试都是一个方法，使用断言来比较预期输出和实际输出。TestNG中测试被组织成类，和JUnit完全相同。但是不同于JUnit，TestNG会使用同一个测试类的实例执行所有测试方法，这意味着测试方法不是默认隔离的，因此在写测试方法的时候要注意是否会相互影响。

2.断言  
一般情况下JUnit自带的Assert断言能满足基本的测试需要。同时也有其他库提供了优秀的断言方式，如Hamcrest和AssertJ。相对于JUnit，Hamcrest表达能力更强，提供的断言更多，写出的断言更利于理解。和Hamcrest一样，AssertJ也提供了很多断言，除此外最大的特点是AssertJ可以将断言串联，让断言的可读性更强。

3.代码覆盖率  
Java Code Coverage(JaCoCo)是一个著名的测试覆盖率测量工具。JaCoCo能提供语句覆盖、分支覆盖等多种覆盖，同时还能生成覆盖率网页，直观的显示哪一行语句或哪一个分支未被测试覆盖。

## 4. 单元测试、集成测试和功能测试

1.什么是单元测试  
将一个大的系统细分成小的单元，对每一个小的单元进行测试就是单元测试。在Java中单元就是方法。

2.为什么不仅仅使用单元测试  
单元测试并不能满足所有的测试需求，比如于数据库建立连接或检查网站是否能正常跳转。

3.单元测试  
单元测试的目标是对小型功能单元进行检查。对于其他类、方法或数据库的调用都应该在内存中完成，这是使用模拟的对象实现的。

4.集成测试  
集成测试的目标是核实各个单元、模块、应用程序乃至系统被妥善集成在一起。一般对于数据库的测试属于集成测试。

5.功能测试  
功能测试的目标是对整个系统功能进行测试。在功能测试中我们应该以用户的角度取编写测试，检查系统是否能按用户的预期想法正常运行。

单元测试、集成测试和功能测试如同一座金字塔一样。单元测试位于最底层，涉及的业务最多，测试的数量也最大。因为单元测试于代码紧密结合，单元测试耗费的成本最小，测试覆盖率最高。而功能测试位于顶端，编写的测试里不因涉及任何代码层面的条件。因为功能测试成本大而且覆盖率低，功能测试的数量远少于单元测试和集成测试。

## 5. 单元测试消除外部依赖

在单元测试中我们只关心我们要测试的最小单元，但是不可避免会有外部依赖，如果为了测试一个单元而构建大量外部依赖，测试会称为瓶颈。所以我们使用模拟实现的外部依赖来对单元进行测试。

Mockito是一个模拟框架，其API简单整洁。Mockito主要有3个静态方法：mock()、spy()和verify()。  
mock方法会创建模拟对象模拟全部的方法，你可以使用when()和given()来指定这些模拟对象的行为。  
spy方法会创建间谍对象模拟部分的方法，没有特殊说明时间谍对象会执行实际的方法。间谍对象也可以指定其行为，于模拟对象的区别在于mock会创建一个完全伪造的对象而spy会使用实际对象。  
verify方法用于检查调用方法是提供的是否是指定的参数或方法运行的次数，这是一种断言。

## 6. 功能测试模拟用户行为

在功能测试中我们不需要知道任何有关实现的细节，我们只关心程序是不是按照客户的预期正常运行。  
Selenium是一组用于自动化浏览器的驱动程序，我们可以使用它操作浏览器和页面元素，如单击按钮、填写表单、打开URL等。几乎适用于所有的浏览器。  
Selenide是对于Selenium的一个包装，其API更简洁，还支持Ajax、jQuery式选择器。
